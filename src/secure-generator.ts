import * as crypto from "crypto";
import {UrlSafeBase64} from "./urlsafe-base64";
import {CharacterSetEnum, CharacterSets} from "./charset";
import {customAlphabet, nanoid} from "nanoid";
import * as util from "util";

export enum ByteEncoding {
    HEX = "hex",
    BASE64 = "base64",
    BASE64_URL_SAFE = "base64UrlSafe",
}

export enum StringCaseEnum {
    SKIP,
    LOWER_CASE,
    UPPER_CASE,
}

export type RandomStringFunc = () => string;

const getRandomStringFn = (length: number, charSet: string): RandomStringFunc => {
    return customAlphabet(charSet, length);
};

export interface RandomStringOption {
    length?: number;
    charSet?: CharacterSetEnum;
    overrideCase?: StringCaseEnum;
    pattern?: string;
}

/**
 * Generate a secure random string from character set with defined length.
 * String is secure-random generated using nanoid
 *
 * @param {Object} [options] Options
 * @param {number} [options.length=21] Length of generated string
 * @param {CharacterSetEnum} [options.charSet=0] Random character sets
 * @param {StringCaseEnum} [options.overrideCase=0] - Override result case
 * @param {string=} [options.pattern] Format pattern to print generated result using Node util.format function
 * @return {string} Result
 */
const randomString = (options: RandomStringOption = {}): string => {
    // Get length configuration
    let {length} = options;
    if (!length) {
        // Set length default to 21
        length = 21;
    }

    // Init value
    let value;

    // Get random set configuration
    const {charSet} = options;
    switch (charSet) {
        case CharacterSetEnum.ALPHA:
        case CharacterSetEnum.ALPHA_NUM:
        case CharacterSetEnum.ALPHA_NUM_MIXED_CASE:
        case CharacterSetEnum.NUM: {
            value = customAlphabet(CharacterSets[charSet], length)();
            break;
        }
        case CharacterSetEnum.DEFAULT:
        default: {
            value = nanoid(length);
            break;
        }
    }

    // Override case
    const {overrideCase} = options;
    switch (overrideCase) {
        case StringCaseEnum.LOWER_CASE: {
            value = value.toLowerCase();
            break;
        }
        case StringCaseEnum.UPPER_CASE: {
            value = value.toUpperCase();
            break;
        }
        case StringCaseEnum.SKIP:
        default: {
            // Skip
            break;
        }
    }

    // Check formatting
    const {pattern} = options;
    if (pattern) {
        value = util.format(pattern, value);
    }

    return value;
};

/**
 * Generate a secure random bytes with defined length
 *
 * @param {Object} [options] Options
 * @param {number} [options.length=32] Length of generated bytes
 * @param {ByteEncoding} [options.encoding="base64UrlSafe"] Override result case
 * @return {string} - Result
 */
const randomBytes = (options: { length?: number; encoding?: ByteEncoding }): string => {
    // Get byte length
    let {length} = options;
    if (!length) {
        length = 32;
    }

    // Generate secure random bytes
    const buf = crypto.randomBytes(length);

    // Encode
    let value: string;
    switch (options.encoding) {
        case ByteEncoding.HEX:
        case ByteEncoding.BASE64: {
            value = buf.toString(options.encoding);
            break;
        }
        case ByteEncoding.BASE64_URL_SAFE:
        default: {
            value = UrlSafeBase64.encode(buf);
            break;
        }
    }
    return value;
};

export const SecureGenerator = {
    randomString,
    randomBytes,
    getRandomStringFn,
};
